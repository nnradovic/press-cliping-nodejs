var phantom = require('phantom')
var fs = require('fs')
var cheerio = require('cheerio')
var keyword_extractor = require("keyword-extractor");
var _ = require('lodash')
var request = require('request')
var normalizeUrl = require('normalize-url');

var paperSize = {
    format: 'A4',
    orientation: 'portrait',
    margin: '1cm'
};

function _pdfgenerator(options,callback){
	this.pathTohtml = options.pathTohtml;
	this.pathTopdf  = options.pathTopdf;
	this.paperSize = options.paperSize || paperSize;

	var _ph,_page,_outObj;

	phantom.create().then(ph=>{
		_ph = ph
		return _ph.createPage()
	}).then(page=>{
		_page = page;

		_page.property('paperSize',this.paperSize)

		return _page.open(this.pathTohtml)
	}).then(status=>{
		return _page.render(this.pathTopdf)
	}).then(content=>{
		if(content){
			if(typeof callback != 'function') console.dir('pdf created');
			callback(null,content)
		}
		_page.close()
		setTimeout(function(){
			_ph.exit()
		},1000)
	}).catch(e=>{if(callback==undefined)throw e;callback(e)})
};

function _validate_pdf(options,callback){
	if(typeof options.pathTohtml==='undefined'){
		if(typeof callback != 'function') throw new Error(`missing property : pathTohtml`)
	 	return callback(new Error(`missing property : pathTohtml`))
	}
	if(typeof options.pathTopdf==='undefined'){
		if(typeof callback != 'function') throw new Error(`missing property : pathTopdf`)
	 	return callback(new Error(`missing property : pathTopdf`))
	}

	fs.exists(options.pathTohtml, (exists) => {
	  	if(!exists){
			if(typeof callback != 'function') throw new Error(`path ${options.pathTohtml} does not exists`)
	  		callback(new Error(`path ${options.pathTohtml} does not exists`))
	  	}
	});
};


function wordCount(body){
	var $ = cheerio.load(body)
	$('script').remove(); //remove script
	$('style').remove(); //remove style
	var text = $.text(); //extract text from dom structure 

	var wordArray = text.replace(/[^A-Za-z\s]/g,'').replace(/\s+/g,' ').split(' ').filter(Boolean) //replace non readable letters and numbers and split with spaces then filter the null elements
	text = arrToText(wordArray)

	return density(text)
}

function density(text){
	var _text = text.replace(/[^A-Za-z\s]/g,'').replace(/\s+/g,' ') //trim all spaces and all characters other the A-Z
	
	_text = _text.toLowerCase() 

	var _words = _text.split(' ').filter(Boolean)
	
	var _og_contentLength = _words.length

	console.log(_text,_og_contentLength)

	var _extWords = keyword_extractor.extract(_text,{
	   language:"english",
	   remove_digits: true,
	   return_changed_case:true,
	   remove_duplicates: false
	});
	var _extText = _extWords.join(' ')
	var _ext_contentLength = _extWords.length
	console.log(_extText,_ext_contentLength)

	var wordCount={}

	_extWords.forEach(function(word){
		if(wordCount[word]){
			wordCount[word]++
		}else{
			wordCount[word] = 1
		}
	})

	console.log(wordCount)
	return densityCalc(wordCount,_og_contentLength)
}

function densityCalc(wordCount,totalLength){
	var _density = [];
    for (prop in wordCount) {
        _density.push({
            word: prop,
            count: wordCount[prop],
            percent:+((wordCount[prop]/totalLength)*100).toFixed(2)
        })
    }

    _density.sort(function (a, b) {
        return b.count - a.count;
    });

    return _density = _density.slice(0, 10);
}

function splitWithCaps(string){
	var _stringlen = string.length;
	var _splittedArr = []

	for(var j=0;j<_stringlen;j++){
		if(string.charAt(j)== string.charAt(j).toUpperCase() && string.charAt(j+1) != string.charAt(j+1).toUpperCase()){
			if(j===0){
				_splittedArr.push(string.charAt(j))
			}else{
				_splittedArr.push(' ')
				_splittedArr.push(string.charAt(j))
			}
		}else{
			_splittedArr.push(string.charAt(j))
		}
	}

	return _splittedArr.join('')
}


function arrToText(array){

	var _array = array;
	var _stringArr = []
	for(var i=0,len=_array.length;i<len;i++){
		_stringArr.push(splitWithCaps(_array[i]))
		_stringArr.push(' ')
		_array[i] = _stringArr.join('')
	}
	var text = _.compact(_array)[_array.length-1]

	return text
}


function wordObj(corpus,wordCount){
	var words = [];
    for (prop in corpus) {
        words.push({
            word: prop,
            count: corpus[prop],
            percent:Math.round((corpus[prop]/wordCount)*100 * 100) / 100

        });
    }
    words.sort(function (a, b) {
        return b.count - a.count;
    });
    return word = words.slice(0, 10);
}

function _keywordDensity(options,callback){
	if(options.url){
		var _url = normalizeUrl(options.url)
		
		request(_url,function(err,response,body){
			if(err){
				return callback(err)
			}
			if(response.statusCode===200){
				
				return callback(null,wordCount(body))

			}
		})
	}else if(options.pathTohtml){
		fs.readFile(options.pathTohtml,function(err,result){
			if(err){
				return callback(err)
			}
			var body = result.toString()
			return callback(null,wordCount(body))
		})
	}else{
		return callback(new Error(`missing properties in options argument`))
	}


};

function _validate_keyword(options,callback){
	if(typeof options === 'function'){
		return callback(new Error(`missing argument \'options\'`))
	}
	if(typeof options.pathTohtml === 'undefined' && typeof options.url === 'undefined'){
		return callback(new Error(`missing property : either \'pathTohtml\' or \'url\' is required`))
	}
	if(options.pathTohtml){

		fs.exists(options.pathTohtml, (exists) => {
		  	if(!exists){
				if(typeof callback != 'function') throw new Error(`path ${options.pathTohtml} does not exists`)
		  		callback(new Error(`path ${options.pathTohtml} does not exists`))
		  	}
		});
	}
}

exports.pdf = function(options,callback){
	_validate_pdf(options,callback)
	return _pdfgenerator(options,callback)
}

exports.keywordDensity =function(options,callback){
	_validate_keyword(options,callback)
	return _keywordDensity(options,callback)
}